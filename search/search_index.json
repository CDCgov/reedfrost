{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chain binomials","text":"<p>The package and app calculate:</p> <ol> <li>the probability of particular states (i.e., numbers of susceptible and infected in a certain generation),</li> <li>the distribution of final outbreak sizes, and</li> <li>simulations of individual outbreaks.</li> </ol> <p>Read more about the models and their mathematics.</p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#reedfrost.ChainBinomial","title":"<code>ChainBinomial</code>","text":"<p>               Bases: <code>ABC</code></p> <p>General chain binomial model</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>class ChainBinomial(abc.ABC):\n    \"\"\"General chain binomial model\"\"\"\n\n    def __init__(self, s0: int, params: dict[str, Any], i0: int = 1):\n        assert s0 &gt;= 0\n        assert i0 &gt;= 0\n        self._validate_params(params)\n\n        self.s0 = s0\n        self.i0 = i0\n        self.params = params\n\n    @abc.abstractmethod\n    def _validate_params(self, params: dict[str, Any]) -&gt; None:\n        \"\"\"Validate parameters for the model\"\"\"\n        pass\n\n    def prob_final_s(self, s_inf: int) -&gt; float:\n        \"\"\"Probability of a certain final number of susceptibles\"\"\"\n        assert s_inf &gt;= 0\n        return self.prob_state(s=s_inf, i=0, t=self.s0 + 1)\n\n    def prob_final_i_cum_extra(self, k: int) -&gt; float:\n        \"\"\"Probability of a certain number of infection beyond the initial infection(s)\"\"\"\n        assert k &gt;= 0\n        return self.prob_final_s(s_inf=self.s0 - k)\n\n    def prob_final_i_cum(self, i_cum: int) -&gt; float:\n        \"\"\"Probability of a certain number of total infections, including the initial infection(s)\"\"\"\n        assert i_cum &gt;= 0\n        if i_cum &lt; self.i0:\n            return 0.0\n        else:\n            return self.prob_final_i_cum_extra(k=i_cum - self.i0)\n\n    @functools.cache\n    def prob_state(self, s: int, i: int, t: int) -&gt; float:\n        \"\"\"\n        Probability of being in state (s, i) at time t\n\n        Args:\n            s (int): number of susceptibles\n            i (int): number of infected\n            t (int): generation\n\n        Returns:\n            float: probability mass\n        \"\"\"\n        assert t &gt;= 0\n        assert i &gt;= 0\n        assert s &gt;= 0\n\n        if t == 0 and s == self.s0 and i == self.i0:\n            return 1.0\n        elif t == 0:\n            return 0.0\n        elif s + i &gt; self.s0:\n            return 0.0\n        elif t &gt; 0:\n            return sum(\n                [\n                    self._tp(i, s + i, ip) * self.prob_state(s + i, ip, t - 1)\n                    for ip in range((self.s0 + self.i0) - (s + i) + 1)\n                    if self.prob_state(s + i, ip, t - 1) &gt; 0.0\n                ]\n            )\n        else:\n            raise ValueError(f\"Negative generation {t}\")\n\n    @functools.cache\n    def _tp(self, i, si, ip) -&gt; float:\n        \"\"\"Transition probability\"\"\"\n        return self._pmf_binom(k=i, n=si, p=self._pi(ip))\n\n    @abc.abstractmethod\n    def _pi(self, i: int) -&gt; float:\n        \"\"\"Probability of infection given i infected individuals\"\"\"\n        pass\n\n    @staticmethod\n    def _pmf_binom(k: int, n: int, p: float) -&gt; float:\n        \"\"\"\n        Binomial distribution pmf\n\n        This implementation is substantially faster than scipy.stats.binom.pmf\n\n        Args:\n            k (int): number of successes\n            n (int): number of trials\n            p (float): success probability\n\n        Returns:\n            float: probability mass\n        \"\"\"\n        return scipy.special.binom(n, k) * p**k * (1.0 - p) ** (n - k)\n\n    def simulate(\n        self,\n        rng: np.random.Generator = np.random.default_rng(),\n    ) -&gt; NDArray[np.integer]:\n        \"\"\"\n        Simulate a Reed-Frost outbreak\n\n        Args:\n            rng (np.random.Generator): random number generator\n\n        Returns:\n            NDArray[np.integer]: number of infected in each generation\n        \"\"\"\n        # time series of infections, starting with the initial infected,\n        # is at most of length s + 1\n        it = np.zeros(self.s0 + 1, dtype=np.int64)\n\n        if self.i0 == 0:\n            return it\n\n        it[0] = self.i0\n        s = self.s0\n\n        for t in range(self.s0):\n            if it[t] == 0:\n                break\n\n            next_i = rng.binomial(n=s, p=self._pi(it[t]))\n            it[t + 1] = next_i\n            s = s - next_i\n\n        return it\n</code></pre>"},{"location":"api/#reedfrost.ChainBinomial._pi","title":"<code>_pi(i)</code>  <code>abstractmethod</code>","text":"<p>Probability of infection given i infected individuals</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>@abc.abstractmethod\ndef _pi(self, i: int) -&gt; float:\n    \"\"\"Probability of infection given i infected individuals\"\"\"\n    pass\n</code></pre>"},{"location":"api/#reedfrost.ChainBinomial._pmf_binom","title":"<code>_pmf_binom(k, n, p)</code>  <code>staticmethod</code>","text":"<p>Binomial distribution pmf</p> <p>This implementation is substantially faster than scipy.stats.binom.pmf</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>int</code> <p>number of successes</p> required <code>n</code> <code>int</code> <p>number of trials</p> required <code>p</code> <code>float</code> <p>success probability</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>probability mass</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>@staticmethod\ndef _pmf_binom(k: int, n: int, p: float) -&gt; float:\n    \"\"\"\n    Binomial distribution pmf\n\n    This implementation is substantially faster than scipy.stats.binom.pmf\n\n    Args:\n        k (int): number of successes\n        n (int): number of trials\n        p (float): success probability\n\n    Returns:\n        float: probability mass\n    \"\"\"\n    return scipy.special.binom(n, k) * p**k * (1.0 - p) ** (n - k)\n</code></pre>"},{"location":"api/#reedfrost.ChainBinomial._tp","title":"<code>_tp(i, si, ip)</code>  <code>cached</code>","text":"<p>Transition probability</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>@functools.cache\ndef _tp(self, i, si, ip) -&gt; float:\n    \"\"\"Transition probability\"\"\"\n    return self._pmf_binom(k=i, n=si, p=self._pi(ip))\n</code></pre>"},{"location":"api/#reedfrost.ChainBinomial._validate_params","title":"<code>_validate_params(params)</code>  <code>abstractmethod</code>","text":"<p>Validate parameters for the model</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>@abc.abstractmethod\ndef _validate_params(self, params: dict[str, Any]) -&gt; None:\n    \"\"\"Validate parameters for the model\"\"\"\n    pass\n</code></pre>"},{"location":"api/#reedfrost.ChainBinomial.prob_final_i_cum","title":"<code>prob_final_i_cum(i_cum)</code>","text":"<p>Probability of a certain number of total infections, including the initial infection(s)</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>def prob_final_i_cum(self, i_cum: int) -&gt; float:\n    \"\"\"Probability of a certain number of total infections, including the initial infection(s)\"\"\"\n    assert i_cum &gt;= 0\n    if i_cum &lt; self.i0:\n        return 0.0\n    else:\n        return self.prob_final_i_cum_extra(k=i_cum - self.i0)\n</code></pre>"},{"location":"api/#reedfrost.ChainBinomial.prob_final_i_cum_extra","title":"<code>prob_final_i_cum_extra(k)</code>","text":"<p>Probability of a certain number of infection beyond the initial infection(s)</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>def prob_final_i_cum_extra(self, k: int) -&gt; float:\n    \"\"\"Probability of a certain number of infection beyond the initial infection(s)\"\"\"\n    assert k &gt;= 0\n    return self.prob_final_s(s_inf=self.s0 - k)\n</code></pre>"},{"location":"api/#reedfrost.ChainBinomial.prob_final_s","title":"<code>prob_final_s(s_inf)</code>","text":"<p>Probability of a certain final number of susceptibles</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>def prob_final_s(self, s_inf: int) -&gt; float:\n    \"\"\"Probability of a certain final number of susceptibles\"\"\"\n    assert s_inf &gt;= 0\n    return self.prob_state(s=s_inf, i=0, t=self.s0 + 1)\n</code></pre>"},{"location":"api/#reedfrost.ChainBinomial.prob_state","title":"<code>prob_state(s, i, t)</code>  <code>cached</code>","text":"<p>Probability of being in state (s, i) at time t</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>int</code> <p>number of susceptibles</p> required <code>i</code> <code>int</code> <p>number of infected</p> required <code>t</code> <code>int</code> <p>generation</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>probability mass</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>@functools.cache\ndef prob_state(self, s: int, i: int, t: int) -&gt; float:\n    \"\"\"\n    Probability of being in state (s, i) at time t\n\n    Args:\n        s (int): number of susceptibles\n        i (int): number of infected\n        t (int): generation\n\n    Returns:\n        float: probability mass\n    \"\"\"\n    assert t &gt;= 0\n    assert i &gt;= 0\n    assert s &gt;= 0\n\n    if t == 0 and s == self.s0 and i == self.i0:\n        return 1.0\n    elif t == 0:\n        return 0.0\n    elif s + i &gt; self.s0:\n        return 0.0\n    elif t &gt; 0:\n        return sum(\n            [\n                self._tp(i, s + i, ip) * self.prob_state(s + i, ip, t - 1)\n                for ip in range((self.s0 + self.i0) - (s + i) + 1)\n                if self.prob_state(s + i, ip, t - 1) &gt; 0.0\n            ]\n        )\n    else:\n        raise ValueError(f\"Negative generation {t}\")\n</code></pre>"},{"location":"api/#reedfrost.ChainBinomial.simulate","title":"<code>simulate(rng=np.random.default_rng())</code>","text":"<p>Simulate a Reed-Frost outbreak</p> <p>Parameters:</p> Name Type Description Default <code>rng</code> <code>Generator</code> <p>random number generator</p> <code>default_rng()</code> <p>Returns:</p> Type Description <code>NDArray[integer]</code> <p>NDArray[np.integer]: number of infected in each generation</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>def simulate(\n    self,\n    rng: np.random.Generator = np.random.default_rng(),\n) -&gt; NDArray[np.integer]:\n    \"\"\"\n    Simulate a Reed-Frost outbreak\n\n    Args:\n        rng (np.random.Generator): random number generator\n\n    Returns:\n        NDArray[np.integer]: number of infected in each generation\n    \"\"\"\n    # time series of infections, starting with the initial infected,\n    # is at most of length s + 1\n    it = np.zeros(self.s0 + 1, dtype=np.int64)\n\n    if self.i0 == 0:\n        return it\n\n    it[0] = self.i0\n    s = self.s0\n\n    for t in range(self.s0):\n        if it[t] == 0:\n            break\n\n        next_i = rng.binomial(n=s, p=self._pi(it[t]))\n        it[t + 1] = next_i\n        s = s - next_i\n\n    return it\n</code></pre>"},{"location":"api/#reedfrost.Enko","title":"<code>Enko</code>","text":"<p>               Bases: <code>ChainBinomial</code></p> <p>Enko model</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>class Enko(ChainBinomial):\n    \"\"\"Enko model\"\"\"\n\n    @staticmethod\n    def _validate_params(params: dict[str, Any]) -&gt; None:\n        \"\"\"Validate parameters for the Enko model\"\"\"\n        assert \"k\" in params\n        assert params[\"k\"] &gt;= 0.0\n        assert \"n\" in params\n        assert params[\"n\"] &gt; 0.0\n\n    def _pi(self, i: int) -&gt; float:\n        return 1.0 - (1.0 - i / (self.params[\"n\"] - 1.0)) ** self.params[\"k\"]\n</code></pre>"},{"location":"api/#reedfrost.Enko._validate_params","title":"<code>_validate_params(params)</code>  <code>staticmethod</code>","text":"<p>Validate parameters for the Enko model</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>@staticmethod\ndef _validate_params(params: dict[str, Any]) -&gt; None:\n    \"\"\"Validate parameters for the Enko model\"\"\"\n    assert \"k\" in params\n    assert params[\"k\"] &gt;= 0.0\n    assert \"n\" in params\n    assert params[\"n\"] &gt; 0.0\n</code></pre>"},{"location":"api/#reedfrost.Greenwood","title":"<code>Greenwood</code>","text":"<p>               Bases: <code>ChainBinomial</code></p> <p>Greenwood model</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>class Greenwood(ChainBinomial):\n    \"\"\"Greenwood model\"\"\"\n\n    @staticmethod\n    def _validate_params(params: dict[str, Any]) -&gt; None:\n        \"\"\"Validate parameters for the Greenwood model\"\"\"\n        assert \"p\" in params\n        assert 0.0 &lt;= params[\"p\"] &lt;= 1.0\n\n    def _pi(self, i: int) -&gt; float:\n        return self.params[\"p\"] if i &gt; 0 else 0.0\n</code></pre>"},{"location":"api/#reedfrost.Greenwood._validate_params","title":"<code>_validate_params(params)</code>  <code>staticmethod</code>","text":"<p>Validate parameters for the Greenwood model</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>@staticmethod\ndef _validate_params(params: dict[str, Any]) -&gt; None:\n    \"\"\"Validate parameters for the Greenwood model\"\"\"\n    assert \"p\" in params\n    assert 0.0 &lt;= params[\"p\"] &lt;= 1.0\n</code></pre>"},{"location":"api/#reedfrost.ReedFrost","title":"<code>ReedFrost</code>","text":"<p>               Bases: <code>ChainBinomial</code></p> <p>Reed-Frost model</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>class ReedFrost(ChainBinomial):\n    \"\"\"Reed-Frost model\"\"\"\n\n    @staticmethod\n    def _validate_params(params: dict[str, Any]) -&gt; None:\n        \"\"\"Validate parameters for the Reed-Frost model\"\"\"\n        assert \"p\" in params\n        assert 0.0 &lt;= params[\"p\"] &lt;= 1.0\n\n    def _pi(self, i: int) -&gt; float:\n        return 1.0 - (1.0 - self.params[\"p\"]) ** i\n</code></pre>"},{"location":"api/#reedfrost.ReedFrost._validate_params","title":"<code>_validate_params(params)</code>  <code>staticmethod</code>","text":"<p>Validate parameters for the Reed-Frost model</p> Source code in <code>src/reedfrost/__init__.py</code> <pre><code>@staticmethod\ndef _validate_params(params: dict[str, Any]) -&gt; None:\n    \"\"\"Validate parameters for the Reed-Frost model\"\"\"\n    assert \"p\" in params\n    assert 0.0 &lt;= params[\"p\"] &lt;= 1.0\n</code></pre>"},{"location":"chain_binomial/","title":"Model descriptions","text":"<p>Chain binomial models are discrete time, discrete person, two-dimensional Markov chain models. Epidemiologically, these models track numbers of susceptibles \\(S_t\\) and infected \\(I_t\\) in each generation \\(t\\).</p> <p>In probability theoretic notation, we write \\(S_t\\) and \\(I_t\\) to mean the events that there are a certain number of susceptible and infected individuals in generation \\(t\\). Given an initial state \\((S_0, I_0)\\) and a transition probability \\(P(S_t, I_t | S_{t-1}, I_{t-1})\\), the probability of a particular trajectory \\((S_0, I_0, S_1, I_1, \\ldots, S_t, I_t)\\) is:</p> \\[ P(S_t, I_t | S_{t-1}, I_{t-1}) \\ldots P(S_1, I_1 | S_0, I_0) \\]"},{"location":"chain_binomial/#general-assumptions-and-corollaries","title":"General assumptions and corollaries","text":"<ul> <li>Use an susceptible-infectious-removed infection course, with a fixed population size \\(n\\), so that there always an implicit removed population \\(n - S_t - I_t\\).</li> <li>Infections last one generation.</li> <li>\\(I_t \\sim \\mathrm{Binom}(S_t, \\pi(I_{t-1}))\\), where \\(\\pi\\) is a function that determines the binomial probability based on the number of prior infections (and some fixed parameters). We require that \\(\\pi(0)=0\\). Note that the basic reproduction number is \\(n \\cdot \\pi(1)\\).</li> <li>\\(S_t = S_{t-1} - I_t\\). The number of susceptibles is non-increasing.</li> <li>There is some stopping time \\(\\tau\\) such that \\(I_t=0\\) and \\(S_t = S_\\tau\\) for all \\(t \\geq \\tau\\).</li> </ul>"},{"location":"chain_binomial/#models","title":"Models","text":""},{"location":"chain_binomial/#reed-frost","title":"Reed-Frost","text":"<p>Each infected person has an independent probability \\(p\\) of infecting each susceptible person:</p> \\[ \\pi(i) = 1 - (1 - p)^i \\] <p>The basic reproduction number is \\(R_0 = np\\).</p>"},{"location":"chain_binomial/#greenwood","title":"Greenwood","text":"<p>If there is at least one infected person, then each susceptible person has a static probability \\(p\\) of being infected:</p> \\[ \\pi(i) = \\begin{cases} p &amp; i &gt; 0 \\\\ 0 &amp; i = 0 \\end{cases} \\] <p>Like for the Reed-Frost model, \\(R_0=np\\). Thus, if a Reed-Frost and Greenwood simulation are matched on \\(R_0\\), then the Greenwood model will generally proceed with a lower force of infection.</p>"},{"location":"chain_binomial/#enko","title":"En'ko","text":"<p>Each susceptible person makes \\(k\\) successful contacts per generation:</p> \\[ \\pi(i) = 1 - \\left(1 - \\frac{i}{n-1}\\right)^k \\] <p>In this case, \\(R_0 = n \\left[ 1 - \\left(1 - \\tfrac{1}{n-1}\\right)^k \\right]\\), from which we can derive:</p> \\[ k = \\frac{\\log (1 - R_0/n)}{\\log [1 - 1/(n-1)]} \\]"},{"location":"chain_binomial/#implementation","title":"Implementation","text":"<p>Let \\(P(s, i, t)\\) be the probability of being in state \\((s, i)\\) in generation \\(t\\). Begin from an initial state, setting \\(P(s_0, i_0, 0) = 1\\). Then iteratively generate:</p> \\[ P(s, i, t) = \\sum_{i'=0}^{s_0-s-i} f_\\mathrm{Binom}(i; s+i, \\pi(i') ) \\cdot P(s + i, i', t - 1) \\] <p>These values can then be summarized to generate outcomes like final size distributions and the probability of intermediate states.</p> <p>This implementation has \\(\\mathcal{O}(n^3)\\) complexity, which in practice is not limiting for simulations with \\(n \\lesssim 100\\).</p>"},{"location":"chain_binomial/#alternative-implementations","title":"Alternative implementations","text":"<p>Lefevre &amp; Picard (1990) describe a \\(\\mathcal{O}(n)\\) algorithm for computing the final size distribution of Reed-Frost outbreaks. In practice, we found that this approach suffers from problems with overflows and numerical instability that were less tractable than the memory and time challenges with the dynamic programming approach. This approach also does not permit the use of different chain binomial models or the intermediate state probability calculations.</p> <p>Barbour &amp; Utev (2004) describe a \\(\\mathcal{O}(n)\\) algorithm for computing an approximation of the final size distribution that is valid for large Reed-Frost outbreaks. This approach is tractable and numerically stable, but it is limited to large outbreaks, does not permit the use of different chain binomial models or the intermediate state probability calculations.</p>"}]}